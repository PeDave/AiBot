@page "/"
@using BitgetApi.Dashboard.Web.Services
@using BitgetApi.Dashboard.Web.Components
@inject PortfolioService Portfolio
@inject PriceTrackerService PriceTracker
@implements IAsyncDisposable

<PageTitle>Bitget Wallet Dashboard</PageTitle>

<div class="dashboard">
    <h1>BITGET LIVE MARKET DASHBOARD v1.0</h1>
    
    <div class="status-bar">
        <span class="status connected">‚óè Connected</span>
        <span class="uptime">Uptime: @uptime.ToString(@"hh\:mm\:ss")</span>
        <span class="last-update">Last update: @lastUpdate.ToString("HH:mm:ss")</span>
    </div>
    
    <!-- WALLET OVERVIEW -->
    <WalletOverview Summary="@portfolioSummary" />
    
    <!-- ASSET LIST -->
    <AssetList Assets="@(portfolioSummary?.Assets ?? new List<AssetBalance>())" />
    
    <!-- PRICE CARDS -->
    <div class="prices-container">
        @foreach (var symbol in symbols)
        {
            var price = PriceTracker.GetPrice(symbol);
            <PriceCard Symbol="@symbol" Price="@price" />
        }
    </div>
</div>

@code {
    private readonly string[] symbols = { "BTCUSDT", "ETHUSDT", "XRPUSDT" };
    
    private PortfolioSummary? portfolioSummary;
    private TimeSpan uptime;
    private DateTime startTime;
    private DateTime lastUpdate;
    private System.Threading.Timer? refreshTimer;
    private bool isRefreshing = false;
    
    protected override async Task OnInitializedAsync()
    {
        startTime = DateTime.Now;
        
        // Subscribe to price updates
        PriceTracker.OnPriceUpdated += OnDataUpdated;
        foreach (var symbol in symbols)
        {
            await PriceTracker.SubscribeAsync(symbol);
        }
        
        // Load portfolio
        await RefreshPortfolioAsync();
        
        // Auto-refresh every 30 seconds
        refreshTimer = new System.Threading.Timer(async _ =>
        {
            uptime = DateTime.Now - startTime;
            
            // Prevent overlapping refreshes
            if (!isRefreshing)
            {
                try
                {
                    await RefreshPortfolioAsync();
                    await InvokeAsync(StateHasChanged);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Timer refresh error: {ex.Message}");
                }
            }
        }, null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
    }
    
    private async Task RefreshPortfolioAsync()
    {
        if (isRefreshing) return;
        
        isRefreshing = true;
        try
        {
            portfolioSummary = await Portfolio.GetPortfolioSummaryAsync();
            lastUpdate = DateTime.Now;
            
            if (!portfolioSummary.HasError)
            {
                Console.WriteLine($"Portfolio refreshed: Total ${portfolioSummary.TotalBalance:N2}");
            }
            else
            {
                Console.WriteLine($"Portfolio refresh failed: {portfolioSummary.ErrorMessage}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing portfolio: {ex.Message}");
        }
        finally
        {
            isRefreshing = false;
        }
    }
    
    private void OnDataUpdated()
    {
        InvokeAsync(StateHasChanged);
    }
    
    public async ValueTask DisposeAsync()
    {
        PriceTracker.OnPriceUpdated -= OnDataUpdated;
        refreshTimer?.Dispose();
    }
}